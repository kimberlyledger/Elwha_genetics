---
title: "steelhead_PCA_LEA"
author: "Kimberly Ledger"
date: "4/12/2022"
output: github_document
---

# looking at O.mykiss population structure using all non-outlier loci  

load libraries
```{r, message = FALSE}
library(adegenet) #this package is used for analysis of genetic/genomic data 
library(dplyr) # data manipulation
library(tidyr) # data manipulation
library(forcats)
```


# Part 1: create genind objects

```{r}
onmy_n_df <- read.csv("outputs/omy_loci4genstr.csv")
```

## create a genind object for all samples using time/location as population
```{r}
geno_n <- onmy_n_df[,c(2:272)]
rownames(geno_n) <- onmy_n_df$Sample_ID
col_geno_n <- gsub("\\.", "_", colnames(geno_n))
colnames(geno_n) <- col_geno_n

meta_n <- onmy_n_df[,-c(1:272)]

loci <- colnames(geno_n)
ind <- rownames(geno_n)
location <- meta_n$Location
time <- meta_n$Time
tp <- meta_n$Time_Location

onmy_genind_tp <- df2genind(geno_n,
                         sep="/",
                         ind.names=ind,
                         loc.names=loci, 
                         pop = tp,
                         ploidy = 2)
onmy_genind_tp
```

here i will subset PRE, DURING, and POST dam individuals 
```{r}
geno_pre <- onmy_n_df %>%
  filter(Time == "Pre") %>%
  dplyr::mutate(Location = fct_relevel(Location, "BD", "SBLR", "ID", "AD")) %>% 
  arrange(Location, rkm)

geno_post <- onmy_n_df %>%
  filter(Time == "Post") %>%
  dplyr::mutate(Location = fct_relevel(Location, "BD", "SBLR", "ID", "AD")) %>% 
  arrange(Location, rkm)
```

## create genind objects from pre and post dam samples (during excluded because there are few)

```{r}
geno_n_pre <- geno_pre[,c(2:272)]
rownames(geno_n_pre) <- geno_pre$Sample_ID
col_geno_n_pre <- gsub("\\.", "_", colnames(geno_n_pre))
colnames(geno_n_pre) <- col_geno_n_pre

meta_pre <- geno_pre[,-c(1:272)]

pre_loci <- colnames(geno_n_pre)
pre_ind <- rownames(geno_n_pre)
pre_location <- meta_pre$Location
pre_rkm <- meta_pre$rkm
pre_site <- meta_pre$Sampling_Site

onmy_genind_pre_location <- df2genind(geno_n_pre,
                         sep="/",
                         ind.names=pre_ind,
                         loc.names=pre_loci, 
                         pop = pre_location,     
                         ploidy = 2)
onmy_genind_pre_site <- df2genind(geno_n_pre,
                         sep="/",
                         ind.names=pre_ind,
                         loc.names=pre_loci, 
                         pop = pre_site,      
                         ploidy = 2)
onmy_genind_pre_location
onmy_genind_pre_site


geno_n_post <- geno_post[,c(2:272)]
rownames(geno_n_post) <- geno_post$Sample_ID
col_geno_n_post <- gsub("\\.", "_", colnames(geno_n_post))
colnames(geno_n_post) <- col_geno_n_post

meta_post <- geno_post[,-c(1:272)]

post_loci <- colnames(geno_n_post)
post_ind <- rownames(geno_n_post)
post_location <- meta_post$Location
post_rkm <- meta_post$rkm
post_site <- meta_post$Sampling_Site

onmy_genind_post_location <- df2genind(geno_n_post,
                         sep="/",
                         ind.names=post_ind,
                         loc.names=post_loci, 
                         pop = post_location,
                         ploidy = 2)

onmy_genind_post_site <- df2genind(geno_n_post,
                         sep="/",
                         ind.names=post_ind,
                         loc.names=post_loci, 
                         pop = post_site,
                         ploidy = 2)
onmy_genind_post_location
onmy_genind_post_site
```


# Part 2: Hardy-Weinberg equilibrium 

## check for deviations from hardy-weinberg equilibrium at the population level - TIME/LOCATION AS POP
```{r, message=FALSE}
onmy_neutral_hw_test <- data.frame(sapply(seppop(onmy_genind_tp), 
                              function(ls) pegas::hw.test(ls, B = 0)[,3])) #skipping permutation test

onmy_neutral_hw_chisq <- t(data.matrix(onmy_neutral_hw_test))

Chisq.fdr <- matrix(p.adjust(onmy_neutral_hw_chisq,method="fdr"), 
                    nrow=nrow(onmy_neutral_hw_chisq))

# proportion of loci out of HWE 
alpha=0.05
Prop.loci.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 2, mean),
                                   Chisq.fdr=apply(Chisq.fdr<alpha, 2, mean))
#Prop.loci.out.of.HWE %>%
#  filter(Chisq >= 0.5)
Prop.loci.out.of.HWE %>%
  filter(Chisq.fdr >= 0.5)

# for each population, the proportion of loci out of HWE
Prop.pops.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 1, mean), 
           Chisq.fdr=apply(Chisq.fdr<alpha, 1, mean))
Prop.pops.out.of.HWE             
```

**8 loci** consistently out of HWE 
**no locations** consistently out of HWE 


## check for deviations from hardy-weinberg equilibrium at the population level - PRE-DAM samples with LOCATION AS POP
```{r, message=FALSE}
onmy_neutral_hw_test <- data.frame(sapply(seppop(onmy_genind_pre_location), 
                              function(ls) pegas::hw.test(ls, B = 0)[,3])) #skipping permutation test

onmy_neutral_hw_chisq <- t(data.matrix(onmy_neutral_hw_test))

Chisq.fdr <- matrix(p.adjust(onmy_neutral_hw_chisq,method="fdr"), 
                    nrow=nrow(onmy_neutral_hw_chisq))

# proportion of loci out of HWE 
alpha=0.05
Prop.loci.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 2, mean),
                                   Chisq.fdr=apply(Chisq.fdr<alpha, 2, mean))
#Prop.loci.out.of.HWE %>%
#  filter(Chisq >= 0.5)
Prop.loci.out.of.HWE %>%
  filter(Chisq.fdr >= 0.5)

# for each population, the proportion of loci out of HWE
Prop.pops.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 1, mean), 
           Chisq.fdr=apply(Chisq.fdr<alpha, 1, mean))
Prop.pops.out.of.HWE             
```

## check for deviations from hardy-weinberg equilibrium at the population level - POST-DAM samples with LOCATION AS POP
```{r, message=FALSE}
onmy_neutral_hw_test <- data.frame(sapply(seppop(onmy_genind_post_location), 
                              function(ls) pegas::hw.test(ls, B = 0)[,3])) #skipping permutation test

onmy_neutral_hw_chisq <- t(data.matrix(onmy_neutral_hw_test))

Chisq.fdr <- matrix(p.adjust(onmy_neutral_hw_chisq,method="fdr"), 
                    nrow=nrow(onmy_neutral_hw_chisq))

# proportion of loci out of HWE 
alpha=0.05
Prop.loci.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 2, mean),
                                   Chisq.fdr=apply(Chisq.fdr<alpha, 2, mean))
#Prop.loci.out.of.HWE %>%
#  filter(Chisq >= 0.5)
Prop.loci.out.of.HWE %>%
  filter(Chisq.fdr >= 0.5)

# for each population, the proportion of loci out of HWE
Prop.pops.out.of.HWE <- data.frame(Chisq=apply(onmy_neutral_hw_chisq<alpha, 1, mean), 
           Chisq.fdr=apply(Chisq.fdr<alpha, 1, mean))
Prop.pops.out.of.HWE             
```

do we need to filter additional loci??? 


# Part 3: assessing population structure 

## start with running PCAs using adegenet package and genind object with all individuals

extract allele frequencies 
```{r}
x.onmy <- tab(onmy_genind_tp, freq = T, NA.method = "mean") 
```

```{r}
pca.onmy <- dudi.pca(df = x.onmy, center = T, scale = F, scannf = FALSE, nf = 200)
```

pc1 vs pc2
```{r}
s.class(pca.onmy$li, fac=pop(onmy_genind_tp),
        xax=1, yax=2, col=transp(funky(15),.6),
        axesel=FALSE, cstar=0, cpoint=3)
```

pc2 v pc3
```{r}
s.class(pca.onmy$li, fac=pop(onmy_genind_tp),
        xax=2, yax=3, col=transp(funky(15),.6),
        axesel=FALSE, cstar=0, cpoint=3)
#add.scatter.eig(pca.onmy$eig[1:50],3,2,3, ratio=.3)
```

## PCAs using adegenet package and genind object with predam individuals by site 

extract allele frequencies 
```{r}
pre.onmy_site <- tab(onmy_genind_pre_site, freq = T, NA.method = "mean") 
```

```{r}
pca.onmy.pre_site <- dudi.pca(df = pre.onmy_site, center = T, scale = F, scannf = FALSE, nf = 200)
```

```{r}
s.class(pca.onmy.pre_site$li, fac=pop(onmy_genind_pre_site),
        xax=1, yax=2, col=transp(funky(14),.6),
        axesel=FALSE, cstar=0, cpoint=3)
#pca.legend(pca.onmy.pre, groups = pre_site)
#add.scatter.eig(pca.onmy.pre$eig[1:50],3,1,2, ratio=.3)
```

## PCAs using adegenet package and genind object with predam individuals by location  

extract allele frequencies 
```{r}
pre.onmy_location <- tab(onmy_genind_pre_location, freq = T, NA.method = "mean") 
```

```{r}
pca.onmy.pre_location <- dudi.pca(df = pre.onmy_location, center = T, scale = F, scannf = FALSE, nf = 200)
```

```{r}
s.class(pca.onmy.pre_location$li, fac=pop(onmy_genind_pre_location),
        xax=1, yax=2, col=transp(c("blue", "darkgreen", "orange", "red"),.6),
        axesel=FALSE, cstar=0, cpoint=3)
```

## PCAs using adegenet package and genind object with postdam individuals by site 

extract allele frequencies 
```{r}
post.onmy_site <- tab(onmy_genind_post_site, freq = T, NA.method = "mean") 
```

```{r}
pca.onmy.post_site <- dudi.pca(df = post.onmy_site, center = T, scale = F, scannf = FALSE, nf = 200)
```

```{r}
s.class(pca.onmy.post_site$li, fac=pop(onmy_genind_post_site),
        xax=1, yax=2, col=transp(funky(14),.6),
        axesel=FALSE, cstar=0, cpoint=3)
#add.scatter.eig(pca.onmy.post$eig[1:50],3,1,2, ratio=.3)
```

## PCAs using adegenet package and genind object with postdam individuals by location 

extract allele frequencies 
```{r}
post.onmy_location <- tab(onmy_genind_post_location, freq = T, NA.method = "mean") 
```

```{r}
pca.onmy.post_location <- dudi.pca(df = post.onmy_location, center = T, scale = F, scannf = FALSE, nf = 200)
```

```{r}
s.class(pca.onmy.post_location$li, fac=pop(onmy_genind_post_location),
        xax=1, yax=2, col=transp(c("blue", "darkgreen", "orange", "red"), .6),
        axesel=FALSE, cstar=0, cpoint=3)
#add.scatter.eig(pca.onmy.post$eig[1:50],3,1,2, ratio=.3)
```

# Part 4: convet genind to genlight objects 

```{r, message=FALSE}
#install_github("green-striped-gecko/dartR")
library(dartR)

genlit_all <- gi2gl(onmy_genind_tp)

genlit_pre_site <- gi2gl(onmy_genind_pre_site)
genlit_pre_location <- gi2gl(onmy_genind_pre_location)
genlit_post_site <- gi2gl(onmy_genind_post_site)
genlit_post_location <- gi2gl(onmy_genind_post_location)
```

# consider filtering genlight objects prior to running a PCA or PCoA?  

prep for pca 
(a) Filter stringently on call rate, using a threshold of at least 95% loci called.
(b) Remove individuals for which call rate is exceptionally low, say <80%.
(c) Impute the remaining missing values on a population‐by‐population basis, where populations can be considered panmictic.
```{r}
genlit_filter <- gl.filter.callrate(genlit_pre_site, method="loc", threshold=0.90)
genlit_filter <- gl.filter.callrate(genlit_filter, method="ind", threshold=0.80)
genlit_filter <- gl.impute(genlit_filter, method="random")
pcoa <- gl.pcoa(genlit_filter)
```

this is for pre-dam samples only 
```{r}
library(directlabels)
gl.pcoa.plot(pcoa, genlit_filter, xaxis = 1, yaxis =2, ellipse = TRUE, plevel = 0.9)
```

##PCA using filtered genlight object

```{r}
pca <- glPca(genlit_filter, center = T, scale = F, nf = 50)
s.class(pca$scores, pop(genlit_filter),
        xax=1, yax=2, col=transp(funky(14),.6),
        axesel=FALSE, cstar=0, cpoint=3)
```

filtering the genlight object does not seem to make a big difference...  


# Part 5: STRUCTURE analyses 

## Clustering with SNMF (similar to ‘STRUCTURE’)

this uses the package LEA
```{r}
library('LEA')
```


### convert the genlight object to geno - will work with pre and post dam individuals seperately

```{r}
geno_pre <- gl2geno(genlit_pre_location, outfile = "gl_geno_pre", outpath = "~/Desktop/LG_Proj4/Elwha_genetics/geno/")
geno_post <- gl2geno(genlit_post_location, outfile = "gl_geno_post", outpath = "~/Desktop/LG_Proj4/Elwha_genetics/geno/")
```


## predam STRUCTURE only 

estimate K 
```{r, message=FALSE}
snmf2 <- LEA::snmf("~/Desktop/LG_Proj4/Elwha_genetics/geno/gl_geno_pre.geno", K=1:8, ploidy=2, entropy=T, 
                   alpha=100, project="new")
par(mfrow=c(1,1))
plot(snmf2, col="blue4", cex=1.4, pch=19)
```

for now i will use K=5
```{r}
K = 5
pre_snmf_5 <- LEA::snmf("~/Desktop/LG_Proj4/Elwha_genetics/geno/gl_geno_pre.geno", K=K, ploidy=2, entropy=T, alpha=100, project="new")
```

plot ancestral populations - samples are sorted by location and river km 
```{r}
qmatrix = LEA::Q(pre_snmf_5, K = K)

par(mar=c(4,4,0.5,0.5))
barplot(t(qmatrix), col=RColorBrewer::brewer.pal(9,"Paired"), 
        border=NA, space=0, xlab="Individuals", 
        ylab="Admixture coefficients")
#Add population labels to the axis:
#for (i in 1:length(pre_site)){
#  axis(1, at=median(which(pre_site==pre_site[i])), labels=pre_site[i])}
#Add population labels to the axis:
for (i in 1:length(pre_location)){
  axis(1, at=min(which(pre_location==pre_location[i])), labels=pre_location[i])}
```


## POSTdam STRUCTURE only 

estimate K 
```{r, message=FALSE}
snmf2 <- LEA::snmf("~/Desktop/LG_Proj4/Elwha_genetics/geno/gl_geno_post.geno", K=1:8, ploidy=2, entropy=T, alpha=100, project="new")
par(mfrow=c(1,1))
plot(snmf2, col="blue4", cex=1.4, pch=19)
```

not sure what k to use... 
for now i will use K=4
```{r}
K = 4
post_snmf_4 <- LEA::snmf("~/Desktop/LG_Proj4/Elwha_genetics/geno/gl_geno_post.geno", K=K, ploidy=2, entropy=T, alpha=100, project="new")
```

plot ancestral populations - samples are sorted by location and river km 
```{r}
qmatrix = LEA::Q(post_snmf_4, K = K)

par(mar=c(4,4,0.5,0.5))
barplot(t(qmatrix), col=RColorBrewer::brewer.pal(9,"Paired"), 
        border=NA, space=0, xlab="Individuals", 
        ylab="Admixture coefficients")
#Add population labels to the axis:
#for (i in 1:length(pre_site)){
#  axis(1, at=median(which(pre_site==pre_site[i])), labels=pre_site[i])}
#Add population labels to the axis:
for (i in 1:length(pre_location)){
  axis(1, at=min(which(pre_location==pre_location[i])), labels=pre_location[i])}
```

