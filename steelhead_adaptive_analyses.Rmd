---
title: "steelhead_adaptive_analyses"
author: Jong Yoon Jeon
objective: steelhead genetic analyses using adaptive loci only
date: Mar 14 2022
output: github_document
---

##Load packages
```{r}
library(vcfR)
library(adegenet)
library(pegas)
library(poppr)
library(dplyr)
library(readr)
library(readxl)
library(tibble)
library(dartR)
```

##Load data
```{r}
steelhead.metadata <- read_csv("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Elwha_Steelhead_Formatted.csv")
steelhead.vcf <- read.vcfR("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Elwha_GTSeq_Sans_CCT.vcf.gz")
steelhead.genind <- vcfR2genind(steelhead.vcf, sep = "/")
steelhead.gt.vcf <- as.data.frame(t(extract.gt(steelhead.vcf, return.alleles = TRUE))) #t for transpose rows and columns
colnames(steelhead.gt.vcf) <- gsub("\\.", "_", colnames(steelhead.gt.vcf)) # Replace ".' to "_" in loci names
#steelhead.gt.genind <- df2genind(steelhead.gt.vcf, sep = "/")
steelhead.snp <- read_csv("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/SNP_Coordinates_CRITFC.csv")
Steelhead.Locus_Key <- read_excel("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Steelhead_Locus_Key.xlsx")
```

##Make a dataframe to store population info
```{r}
steelhead_pop <- matrix(NA, nrow=nrow(steelhead.genind@tab), ncol=8)
steelhead_pop <- as.data.frame(steelhead_pop)
names(steelhead_pop) <- c("Sample_ID", "NvH", "Time", "Location", "Run_Timing", "Life_History_Trait", "Lat", "Long")
```

##Store pop info for each individual
```{r}
for (i in 1:nrow(steelhead.genind@tab)){
  steelhead_pop$Sample_ID[i] <- rownames(steelhead.genind@tab)[i]
  steelhead_pop$NvH[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(NvH_Origin)
  steelhead_pop$Time[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Time)
  steelhead_pop$Location[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Location)
  steelhead_pop$Run_Timing[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Run_Timing)
  steelhead_pop$Life_History_Type[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Life_History_Type)
  steelhead_pop$X[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Long)
  steelhead_pop$Y[i] <- steelhead.metadata %>% filter(Sample_ID == rownames(steelhead.genind@tab)[i]) %>% select(Lat)
}
invisible(steelhead_pop$NvH[lengths(steelhead_pop$NvH) == 0] <- NA_character_)
invisible(steelhead_pop$Time[lengths(steelhead_pop$Time) == 0] <- NA_character_)
invisible(steelhead_pop$Location[lengths(steelhead_pop$Location) == 0] <- NA_character_)
invisible(steelhead_pop$Run_Timing[lengths(steelhead_pop$Run_Timing) == 0] <- NA_character_)
invisible(steelhead_pop$Life_History_Type[lengths(steelhead_pop$Life_History_Type) == 0] <- NA_character_)
invisible(steelhead_pop$X[lengths(steelhead_pop$X) == 0] <- NA_character_)
invisible(steelhead_pop$Y[lengths(steelhead_pop$Y) == 0] <- NA_character_)
steelhead_coord <- cbind(steelhead_pop$Sample_ID, steelhead_pop$X, steelhead_pop$Y)
steelhead.genind@other$xy <- steelhead_coord
#steelhead.gt.genind@other$xy <- steelhead_coord
```

##Divide pop by "Time" and "Location"
```{r}
strata(steelhead.genind) <- steelhead_pop
setPop(steelhead.genind) <- ~Time/Location
steelhead.genind <- steelhead.genind[!is.na(steelhead.genind@strata$Time) & !is.na(steelhead.genind@strata$Location)] #Remove individuals without pop info
#strata(steelhead.gt.genind) <- steelhead_pop
#setPop(steelhead.gt.genind) <- ~Time/Location
#steelhead.gt.genind <- steelhead.gt.genind[!is.na(steelhead.gt.genind@strata$Time) & !is.na(steelhead.gt.genind@strata$Location)] #Remove individuals without pop info
```

##Filter adaptive loci only, removing "character(0)" loci
```{r}
steelhead_adaptive <- Steelhead.Locus_Key %>% filter(grepl('Adaptive', Steelhead.Locus_Key$`SNPeff Annotation output`))
for (i in 1:nrow(steelhead_adaptive)){
  steelhead_adaptive$SnpPos[i] <- steelhead.snp %>% filter(Locus == steelhead_adaptive[i,]$`SNPPIT or Alias`) %>% select(SNP)
}
toRetain <- steelhead_adaptive$SnpPos[lengths(steelhead_adaptive$SnpPos) != 0] #Remove loci without name (character(0))
toRetain <- gsub("\\.", "_", unlist(toRetain)) # Replace ".' to "_"
steelhead_adaptive.genind <- steelhead.genind[loc=unlist(toRetain)]
steelhead_adaptive.gt.vcf <- steelhead.gt.vcf[, names(steelhead.gt.vcf) %in% toRetain] #Retain adaptive loci only
#steelhead_adaptive.genind locus name change from SnpPos to SnpName? - manually after allele frequency calculation
```

##HWE test for each pop (by "Time" or by "Location")
```{r}
steelhead_pop <- steelhead_pop %>% filter(!is.na(steelhead_pop$Time) & !is.na(steelhead_pop$Location)) #Remove individuals without pop info
strata(steelhead_adaptive.genind) <- steelhead_pop

setPop(steelhead_adaptive.genind) <- ~Time #by "Time"
steelhead_time_hwt <- seppop(steelhead_adaptive.genind) %>% lapply(hw.test, B = 0)
write.table(steelhead_time_hwt, file = "steelhead_time_hwt.txt", sep = "\t")

setPop(steelhead_adaptive.genind) <- ~Location #by "Location"
steelhead_location_hwt <- seppop(steelhead_adaptive.genind) %>% lapply(hw.test, B = 0)
write.table(steelhead_location_hwt, file = "steelhead_location_hwt.txt", sep = "\t")
```

##Transform to genpop object and calculate allele frequencies
```{r}
#Assign population by "Time" + "Location"
setPop(steelhead_adaptive.genind) <- ~Time/Location
steelhead_adaptive.genpop <- genind2genpop(steelhead_adaptive.genind)
steelhead_af <- makefreq(steelhead_adaptive.genpop, missing = NA)
```

##PCA using only adaptive loci
```{r}
library(ggplot2)
steelhead_adaptive.genlight <- gi2gl(steelhead_adaptive.genind)
steelhead_adaptive.pca <- glPca(steelhead_adaptive.genlight, center = F, scale = F, nf =50)
steelhead_adaptive.PCA <- as.data.frame(steelhead_adaptive.pca$scores)
steelhead_pop$Location <- factor(steelhead_pop$Location, levels = c("AD", "ID", "BD", "SBLR")) 
steelhead_adaptive.PCA$Color <- steelhead_pop$Location
steelhead_adaptive.PCA$Color <- unlist(steelhead_adaptive.PCA$Color)
steelhead_pop$Time <- factor(steelhead_pop$Time, levels = c("Pre", "During", "Post")) 
steelhead_adaptive.PCA$Shape <- steelhead_pop$Time
steelhead_adaptive.PCA$Shape <- unlist(steelhead_adaptive.PCA$Shape)
steelhead_adaptive.PCA %>% ggplot(aes(x=PC1, y = PC2)) + geom_point(aes(col = Color, shape = Shape), size = 3, alpha=0.5) + 
  labs(color = "Location", shape = "Time")+
  scale_color_manual(values=c("#A9AFD1", "#9D5C63","#29335C", "orange")) + 
  theme_classic() + 
  theme(axis.text = element_text(size = 10, face = "bold"), 
        axis.title = element_text(size = 13, face = "bold"), 
        axis.line = element_line(size = 1.2),
        axis.title.y = element_text(angle = 90),
        legend.position = "bottom", 
        legend.box = "horizontal", 
        legend.title = element_text(face = "bold", size = 16), 
        legend.text = element_text(size = 13, face = "bold"),
        plot.title = element_text(size = 18, face = "bold"))
```

##Plot allele frequency heatmaps of all adaptive loci *update steelhead.heatmap_005 with the updated dataset
```{r}
library(RColorBrewer)
library(gplots)

steelhead_adaptive$SnpPos <- gsub("\\.", "_", steelhead_adaptive$SnpPos)
steelhead_afSNP <- steelhead_af
steelhead_afSNP <- steelhead_afSNP[,order(colnames(steelhead_afSNP))]

#Change loci names from SnpPos to SnpName (="SNPPIT or Alias")
for (i in 1:ncol(steelhead_afSNP)){
  colnames(steelhead_afSNP)[i] <- as.character(steelhead_adaptive[(which(steelhead_adaptive$SnpPos == substr(colnames(steelhead_afSNP)[i], 1, nchar(colnames(steelhead_afSNP)[i])-2))),3]) #3rd column of "steelhead_adaptive" includes SnpName
}

#Change row order as following: Pre_AD, Post_AD, Pre_ID, Post_ID, Pre_BD, During_BD, Post_BD, Post_SBLR
#steelhead_af_ordered <- steelhead_afSNP[c(2, 7, 1, 6, 3, 4, 5, 8),]
steelhead_af_ordered <- steelhead_afSNP[c("Pre_AD", "Post_AD", "Pre_ID", "Post_ID", "Pre_BD", "During_BD", "Post_BD", "Post_SBLR"),]
write.table(steelhead_af_ordered, "steelhead_af.txt", sep = "\t")

steelhead_af_pruned <- read.delim("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Analysis/Steelhead analysis/Elwha_genetics/steelhead_af_pruned.txt", row.names = 1) #Reread manually pruned table to have major allele frequency only for each locus 
steelhead_af_pruned <- as.matrix(steelhead_af_pruned)

heatmap_color <- colorRampPalette(brewer.pal(10,"RdYlBu"))
steelhead.heatmap_all <- heatmap.2(steelhead_af_pruned, main = "Heatmap of all Adpative loci", col=heatmap_color, Rowv = FALSE, Colv = FALSE, dendrogram = "none", trace = "none", density.info = "none", xlab = "Locus", labCol = "", margins = c(2.5,10))

steelhead.heatmap_all_dendro <- heatmap.2(steelhead_af_pruned, main = "Heatmap of all Adpative loci", col=heatmap_color, trace = "none", density.info = "none", xlab = "Locus", labCol = "", margins = c(2.5,10)) #Heatmap with dendrogram option

steelhead_af_005 <- read.delim("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Analysis/Steelhead analysis/Elwha_genetics/steelhead_af_005.txt", row.names=1) #Manually filtered loci to include higher 5% of them in terms of absolute value of allele frequency change between PreDam and PostDam for any of AD, ID, BD
steelhead_af_005 <- as.matrix(steelhead_af_005)

steelhead.heatmap_005 <- heatmap.2(steelhead_af_005, main = "Heatmap of highly affected loci", col=heatmap_color, Rowv = FALSE, Colv = FALSE, dendrogram = "none", trace = "none", density.info = "none", srtCol = 45, margins = c(10,10))
steelhead.heatmap_005_dendro <- heatmap.2(steelhead_af_005, main = "Heatmap of highly affected loci", col=heatmap_color, trace = "none", density.info = "none", srtCol = 45, margins = c(10,10)) #Heatmap with dendrogram option
```

##Calculate (observed) genotype frequencies for each pop (Time/Location) and save them to manually re-arrange them
```{r}
library(mixIndependR)
steelhead_pop$Time_Location <- paste0(steelhead_pop$Time,"_",steelhead_pop$Location)
steelhead_adaptive.gt.vcf <- as_tibble(steelhead_adaptive.gt.vcf, rownames = "Sample_ID")
steelhead_adaptive.gt.vcf <- left_join(steelhead_adaptive.gt.vcf, steelhead_pop %>% select(Sample_ID, Time_Location), by = c("Sample_ID" = "Sample_ID"))
steelhead_adaptive.gt.vcf <- steelhead_adaptive.gt.vcf %>% filter(!is.na(steelhead_adaptive.gt.vcf$Time_Location)) #Remove individuals without pop info
steelhead_adaptive$SnpPos <- gsub("\\.", "_", steelhead_adaptive$SnpPos)
steelhead_adaptiveSNP.gt.vcf <- steelhead_adaptive.gt.vcf

#Change loci names from SnpPos to SnpName (="SNPPIT or Alias")
for (i in 1:ncol(steelhead_adaptiveSNP.gt.vcf[-c(1,length(steelhead_adaptiveSNP.gt.vcf))])){
  colnames(steelhead_adaptiveSNP.gt.vcf)[i+1] <- as.character(steelhead_adaptive[(which(steelhead_adaptive$SnpPos == colnames(steelhead_adaptiveSNP.gt.vcf)[i+1])),3]) #3rd column of "steelhead_adaptive" includes SnpName
}

steelhead_adaptiveSNP.gt.vcf_PreAD <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Pre_AD",]
steelhead_adaptiveSNP.gt.vcf_PostAD <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Post_AD",]
steelhead_adaptiveSNP.gt.vcf_PreID <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Pre_ID",]
steelhead_adaptiveSNP.gt.vcf_PostID <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Post_ID",]
steelhead_adaptiveSNP.gt.vcf_PreBD <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Pre_BD",]
steelhead_adaptiveSNP.gt.vcf_DuringBD <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "During_BD",]
steelhead_adaptiveSNP.gt.vcf_PostBD <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Post_BD",]
steelhead_adaptiveSNP.gt.vcf_PostSBLR <- steelhead_adaptiveSNP.gt.vcf[steelhead_adaptiveSNP.gt.vcf$Time_Location == "Post_SBLR",]

steelhead_gf_PreAD <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PreAD[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PreAD)-1)],"/",expect=FALSE) #expect=FALSE to calculate "observed" genotype frequencies
steelhead_gf_PreAD[] <- sapply(steelhead_gf_PreAD, function(x){x/sum(x)}) #Make genotype frequency as "frequency"; default is observed numbers"
steelhead_gf_PreAD$Time_Location <- "Pre_AD"
steelhead_gf_PostAD <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PostAD[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PostAD)-1)],"/",expect=FALSE)
steelhead_gf_PostAD[] <- sapply(steelhead_gf_PostAD, function(x){x/sum(x)})
steelhead_gf_PostAD$Time_Location <- "Post_AD"
write.table(steelhead_gf_PreAD, file = "steelhead_gf_PreAD.txt", sep = "\t")
write.table(steelhead_gf_PostAD, file = "steelhead_gf_PostAD.txt", sep = "\t")

steelhead_gf_PreID <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PreID[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PreID)-1)],"/",expect=FALSE)
steelhead_gf_PreID[] <- sapply(steelhead_gf_PreID, function(x){x/sum(x)})
steelhead_gf_PreID$Time_Location <- "Pre_ID"
steelhead_gf_PostID <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PostID[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PostID)-1)],"/",expect=FALSE)
steelhead_gf_PostID[] <- sapply(steelhead_gf_PostID, function(x){x/sum(x)})
steelhead_gf_PostID$Time_Location <- "Post_ID"
write.table(steelhead_gf_PreID, file = "steelhead_gf_PreID.txt", sep = "\t")
write.table(steelhead_gf_PostID, file = "steelhead_gf_PostID.txt", sep = "\t")

steelhead_gf_PreBD <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PreBD[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PreBD)-1)],"/",expect=FALSE)
steelhead_gf_PreBD[] <- sapply(steelhead_gf_PreBD, function(x){x/sum(x)})
steelhead_gf_PreBD$Time_Location <- "Pre_BD"
steelhead_gf_DuringBD <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_DuringBD[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_DuringBD)-1)],"/",expect=FALSE)
steelhead_gf_DuringBD[] <- sapply(steelhead_gf_DuringBD, function(x){x/sum(x)})
steelhead_gf_DuringBD$Time_Location <- "During_BD"
steelhead_gf_PostBD <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PostBD[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PostBD)-1)],"/",expect=FALSE)
steelhead_gf_PostBD[] <- sapply(steelhead_gf_PostBD, function(x){x/sum(x)})
steelhead_gf_PostBD$Time_Location <- "Post_BD"
write.table(steelhead_gf_PreBD, file = "steelhead_gf_PreBD.txt", sep = "\t")
write.table(steelhead_gf_DuringBD, file = "steelhead_gf_DuringBD.txt", sep = "\t")
write.table(steelhead_gf_PostBD, file = "steelhead_gf_PostBD.txt", sep = "\t")

steelhead_gf_PostSBLR <- GenotypeFreq(steelhead_adaptiveSNP.gt.vcf_PostSBLR[,2:(ncol(steelhead_adaptiveSNP.gt.vcf_PostSBLR)-1)],"/",expect=FALSE)
steelhead_gf_PostSBLR[] <- sapply(steelhead_gf_PostSBLR, function(x){x/sum(x)})
steelhead_gf_PostSBLR$Time_Location <- "Post_SBLR"
write.table(steelhead_gf_PostSBLR, file = "steelhead_gf_PostSBLR.txt", sep = "\t")

#After this, in Excel, manually separate loci according to positions on Greb1 (Premature/Mature and Omy5 (Ancestral/Recombined) and combine files of same Location (e.g. steelhead_gf_BD; combined PreBD + DuringBD + PostBD), because "GenotypeFreq" function removes Sample ID. But you can just make combined files in advance here too, as they retain Pop info.
```

##Plot allele frequency heatmaps of GREB1L loci (*check summer-run/winter-run alleles and modify)
```{r}
#Read files of GREB1L loci genotype frequencies for each run timing (summer-run, heterozygotes, winter-run)
steelhead_gf_summerrun <- read_excel("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Analysis/Steelhead analysis/Elwha_genetics/steelhead_gf_summerrun.xlsx")
steelhead_gf_summerrun <- as.matrix(steelhead_gf_summerrun)
Popinfo <- steelhead_gf_summerrun[,1]
steelhead_gf_summerrun <- steelhead_gf_summerrun[,-1]
steelhead_gf_summerrun <- apply(steelhead_gf_summerrun, 2, as.numeric)
rownames(steelhead_gf_summerrun) <- Popinfo

heatmap_color <- colorRampPalette(brewer.pal(10,"RdYlBu"))

steelhead.heatmap_summerrun <- heatmap.2(steelhead_gf_summerrun, main = "Heatmap of Summer-run", col=heatmap_color, Rowv = FALSE, Colv = FALSE, dendrogram = "none", trace = "none", srtCol = 45, density.info = "none", margins = c(10,10))

steelhead.heatmap_summerrun_dendro <- heatmap.2(steelhead_gf_summerrun, main = "Heatmap of Summer-run", col=heatmap_color, trace = "none", density.info = "none", srtCol = 45, margins = c(10,10)) #Heatmap with dendrogram option


steelhead_gf_heterozygote <- read_excel("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Analysis/Steelhead analysis/Elwha_genetics/steelhead_gf_heterozygote.xlsx")
steelhead_gf_heterozygote <- as.matrix(steelhead_gf_heterozygote)
steelhead_gf_heterozygote <- steelhead_gf_heterozygote[,-1]
steelhead_gf_heterozygote <- apply(steelhead_gf_heterozygote, 2, as.numeric)
rownames(steelhead_gf_heterozygote) <- Popinfo

steelhead.heatmap_heterozygote <- heatmap.2(steelhead_gf_heterozygote, main = "Heatmap of Heterozygote", col=heatmap_color, Rowv = FALSE, Colv = FALSE, dendrogram = "none", trace = "none", srtCol = 45, density.info = "none", margins = c(10,10))

steelhead.heatmap_heterozygote_dendro <- heatmap.2(steelhead_gf_heterozygote, main = "Heatmap of Heterozygote", col=heatmap_color, trace = "none", density.info = "none", srtCol = 45, margins = c(10,10)) #Heatmap with dendrogram option


steelhead_gf_winterrun <- read_excel("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Analysis/Steelhead analysis/Elwha_genetics/steelhead_gf_winterrun.xlsx")
steelhead_gf_winterrun <- as.matrix(steelhead_gf_winterrun)
steelhead_gf_winterrun <- steelhead_gf_winterrun[,-1]
steelhead_gf_winterrun <- apply(steelhead_gf_winterrun, 2, as.numeric)
rownames(steelhead_gf_winterrun) <- Popinfo

steelhead.heatmap_winterrun <- heatmap.2(steelhead_gf_winterrun, main = "Heatmap of Winter-run", col=heatmap_color, Rowv = FALSE, Colv = FALSE, dendrogram = "none", trace = "none", srtCol = 45, density.info = "none", margins = c(10,10))

steelhead.heatmap_winterrun_dendro <- heatmap.2(steelhead_gf_winterrun, main = "Heatmap of Winter-run", col=heatmap_color, trace = "none", density.info = "none", srtCol = 45, margins = c(10,10)) #Heatmap with dendrogram option
```

##Prepare data for NeEstimator (Neutral loci + 1 adaptive loci from Omy5 and Omy28)
```{r}
#Derived and developed from Kim's code for neutral loci analyses
onmy_metadata <- read_csv("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Elwha_Steelhead_Formatted.csv")
onmy_vcf <- read.vcfR("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Elwha_GTSeq_Sans_CCT.vcf.gz")
onmy_genind <- vcfR2genind(onmy_vcf, sep = "/", return.alleles = TRUE)
onmy_pop <- matrix(NA, nrow=nrow(onmy_genind@tab), ncol=8)
onmy_pop <- as.data.frame(onmy_pop)
names(onmy_pop) <- c("Sample_ID", "NvH", "Time", "Location", "Run_Timing", "Life_History_Trait", "Lat", "Long")
for (i in 1:nrow(onmy_genind@tab)){
     onmy_pop$Sample_ID[i] <- rownames(onmy_genind@tab)[i]
     onmy_pop$NvH[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(NvH_Origin)
     onmy_pop$Time[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Time)
     onmy_pop$Location[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Location)
     onmy_pop$Run_Timing[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Run_Timing)
     onmy_pop$Life_History_Type[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Life_History_Type)
     onmy_pop$X[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Long)
     onmy_pop$Y[i] <- onmy_metadata %>% filter(Sample_ID == rownames(onmy_genind@tab)[i]) %>% select(Lat)
 }
invisible(onmy_pop$NvH[lengths(onmy_pop$NvH) == 0] <- NA_character_)
invisible(onmy_pop$Time[lengths(onmy_pop$Time) == 0] <- NA_character_)
invisible(onmy_pop$Location[lengths(onmy_pop$Location) == 0] <- NA_character_)
invisible(onmy_pop$Run_Timing[lengths(onmy_pop$Run_Timing) == 0] <- NA_character_)
invisible(onmy_pop$Life_History_Type[lengths(onmy_pop$Life_History_Type) == 0] <- NA_character_)
invisible(onmy_pop$X[lengths(onmy_pop$X) == 0] <- NA_character_)
invisible(onmy_pop$Y[lengths(onmy_pop$Y) == 0] <- NA_character_)
onmy_coord <- cbind(onmy_pop$Sample_ID, onmy_pop$X, onmy_pop$Y)
onmy_genind@other$xy <- onmy_coord
strata(onmy_genind) <- onmy_pop
setPop(onmy_genind) <- ~Time/Location
onmy_genind <- onmy_genind[!is.na(onmy_genind@strata$Time) & !is.na(onmy_genind@strata$Location)] #Remove individuals without pop info
onmy_loci_meta <- read_excel("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/Steelhead_Locus_Key.xlsx")
onmy_snp_coord <- read_csv("C:/Users/jyj55/Desktop/LGC-DGS_2022/Team_project/Steelhead_genotype/SNP_Coordinates_CRITFC.csv")
onmy_locus_join <- onmy_snp_coord %>%
     left_join(onmy_loci_meta, by = c("Locus" = "SNPPIT or Alias"))
onmy_loci_ne <- onmy_locus_join %>%
     filter(grepl("Neutral", `SNPeff Annotation output`) | Locus == "OmyR14589" | Locus == "Omy_GREB1_05")
library(gsubfn)
onmy_snp_ne <- onmy_loci_ne$SNP
onmy_snp_ne <- gsubfn("\\.", "_", onmy_snp_ne)
onmy_genind_ne <- onmy_genind[loc = onmy_snp_ne]


#step by step genind_to_genepop function of package "graph4lg"
x <- onmy_genind_ne

if(!inherits(x, "genind")){
  stop("Input 'x' must be an object of class 'genind'.")
}  # Check whether 'x' is a genind object

data <- x@tab  # Get genetic data from x@tab
pop_names <- x@pop  # Get pop_names

### Return a message if there is only one population
if(length(unique(pop_names)) == 1){
   message("There is only one population in your dataset")
   unique_pop <- TRUE
} else {
   unique_pop <- FALSE
}

## If the individuals are not ordered by populations, they are reordered with their populations in alphabetic order.
if(!all(pop_names == rep(pop_names[-which(duplicated(pop_names))],
                         times = table(pop_names)[unique(pop_names)]))){
  message("Individuals in the input data were not ordered, they have
        been ordered by populations and populations in alphabetic order
        for the conversion.")
  pop_names <- as.character(x@pop)[order(as.character(x@pop))]
  data <- x@tab[order(as.character(x@pop)),]
} else {
  pop_names <- as.character(x@pop)[order(as.character(x@pop))]
  data <- x@tab[order(as.character(x@pop)),]
}

### Identify the type of markers and modify SNPs data for GENEPOP usage
if(all(unlist(unique(x@all.names)) %in% c("A", "T", "C", "G"))){
  m_type <- "snp"
  message("Your dataset is treated as a SNP dataset.
          Alleles initially coded A, T, C, G were respectively coded
          01, 02, 03 and 04")
  colnames(data) <- gsub(colnames(data),pattern="\\.A",replacement=".01")
  colnames(data) <- gsub(colnames(data),pattern="\\.T",replacement=".02")
  colnames(data) <- gsub(colnames(data),pattern="\\.C",replacement=".03")
  colnames(data) <- gsub(colnames(data),pattern="\\.G",replacement=".04")
  #####
} else {
  m_type <- "msat"
}

# Get loci names
loci_names_l <- x@loc.fac
# Create an empty data.frame
loc_all <- data.frame(col = colnames(data))
# Check whether the names of the locus.allele combination are well formatted
# with a '.' between the locus and the allele names.
if(all(stringr::str_count(colnames(data), "\\.") == 1) != TRUE){
  stop("The columns' names of x@tab must be of form 'locus.allele' with only 1
       '.' between locus and allele")
}
# Separate the locus and the allele
loc_all <- tidyr::separate(loc_all, col = 1, sep = "\\.",
                           into = c("locus", "allele"))
  
# Avoid problems when allele names have not the same number of characters
max_all_chr <- max(nchar(loc_all$allele))
for(i in 1:nrow(loc_all)){
  name_all_chr <- nchar(loc_all[i, "allele"])
  loc_all[i, "allele"] <- ifelse(name_all_chr < max_all_chr,
                                 paste0(rep("0", times = max_all_chr - name_all_chr),
                                        loc_all[i, "allele"]),
                                 loc_all[i, "allele"])
}
loci_names <- as.character(loci_names_l[-which(duplicated(loci_names_l))])
n.loci <- length(loci_names_l[-which(duplicated(loci_names_l))]  )

# Create the data.frame data_gpop which will contain the genetic data
# The first column contains the ID of each individual
data_gpop <- data.frame(id = paste(pop_names, "_", row.names(data), ",",
                                   sep = ""))
data_gpop[] <- lapply(data_gpop, gsub, pattern = " ", replacement = "")
  
# The loop will run over all the loci
for (i in 1:n.loci){
  # loc is the locus considered
  loc <- loci_names[i]
  # a is an empty vector which will contain the two alleles coding of all
  # individuals over all the loci
  a <- c()
  # The loop will run over all the individuals
  for (j in 1:nrow(data)){
    # Get the column corresponding to the locus
    col_loc <- which(loc_all[, 'locus'] == loc)
    # Get the locus.allele at which individual j is homozygote or heterozygote
    hom <- which(data[j,col_loc] == 2)
    het <- which(data[j,col_loc] == 1)
    # If homozygote, then copy the code of the allele twice
    if(length(hom) != 0){
      a[j] <- paste(loc_all[col_loc[hom], 'allele'],
                    loc_all[col_loc[hom], 'allele'],
                    sep = "")
      # If heterozygote, then copy the code of the two alleles of ind j
      # the lower code number is the first
    } else if (length(het) != 0){
      if (as.character(loc_all[col_loc[het[1]], 'allele']) <
          as.character(loc_all[col_loc[het[2]], 'allele'])){
        a[j] <- paste(loc_all[col_loc[het[1]], 'allele'],
                      loc_all[col_loc[het[2]], 'allele'],
                      sep = "")
      } else {
        a[j] <- paste(loc_all[col_loc[het[2]], 'allele'],
                      loc_all[col_loc[het[1]], 'allele'],
                      sep = "")
      }
    } else {
      # If missing data, set 000000 or 0000
      if(nchar(loc_all[1, 'allele'] == 6)){
        a[j] <- "0000"
      } else {
        a[j] <- "0000"
      }
      ###
    }
  }
  # For each locus, add the next column to data_gpop
  data_gpop <- cbind(data_gpop, a)
}

# Then, set the colnames
colnames(data_gpop) <- c("ID", as.character(loci_names))

# Convert all the columns as characters
data_gpop[ , ] <- lapply(data_gpop[ , ], as.character)

# Add the pop_names
# Distinguish the case where there is only one pop
if(unique_pop){
    # Create data_gpop2 whose first line only is "POP"
  data_gpop2 <- rbind(c("Pop",rep("", n.loci)), data_gpop)

} else {

  # Get the rows' numbers of the end of the populations
  num_end_pop <- c()
  for  (i in (1:(length(pop_names) - 1))){
    if (pop_names[i] != pop_names[i + 1]){
      num_end_pop[i] <- i
    } else {
      num_end_pop[i] <- 0
    }
  }
  num_end_pop <- which(num_end_pop != 0)

  # Create data_gpop2 whose first line only is "POP"
  data_gpop2 <- rbind(c("Pop",rep("", n.loci)), data_gpop[1:num_end_pop[1], ])
    # Then, add the rows of each population, one line with "POP", etc..
  for (i in 1:(length(num_end_pop)-1)){
    data_gpop2 <- rbind(data_gpop2, c("Pop", rep("", n.loci)),
                        data_gpop[(num_end_pop[i]+1):num_end_pop[i+1], ])
  }
    # Add the last population
  data_gpop2 <- rbind(data_gpop2, c("Pop", rep("", n.loci)),
                      data_gpop[(num_end_pop[length(num_end_pop)]+1):nrow(data_gpop), ])
  }
  
# The two first lines are the heading and the names of the loci
if(n.loci > 1){
  data_gpop2 <- rbind(c("Conversion of an object of class 'genind' into a GENEPOP file with the package 'graph4lg'",
                        rep("", n.loci)),
                      c(paste(loci_names[1:(n.loci-1)],",", sep = ""),
                        loci_names[n.loci], ""),
                      data_gpop2)
  colnames(data_gpop2)[2:(length(colnames(data_gpop2))-1)] <-
    paste(colnames(data_gpop2)[2:(length(colnames(data_gpop2))-1)], ",", sep = "")
} else {
  data_gpop2 <- rbind(c("Conversion of an object of class 'genind' into a GENEPOP file with the package 'graph4lg'",
                        rep("", n.loci)),
                      c(loci_names[n.loci], ""),
                      data_gpop2)
}

# Output to the current working directory
utils::write.table(data_gpop2,file = "onmy_ne_genepop.txt", quote=FALSE,
                     row.names=FALSE, col.names=FALSE)

# The output file will be input to NeEstimator (sample names should be shortened not to include numbers similar to genotype frequencies)
```

##Calculate DPS based on adaptive loci and change the DPS matrix to column/long format
```{r}
steelhead_adaptive_dps <- 1 - propShared(steelhead_adaptive.genind)
require(reshape2)
temp_m <- as.matrix(steelhead_adaptive_dps)
temp_m[upper.tri(temp_m, diag=TRUE)] <- NA
m <- melt(temp_m)
rm(temp_m)
IndData <- na.omit(m)
IndData <- IndData[, c(2,1,3)] # Change the column order
colnames(IndData) <- c('Ind1', 'Ind2', 'DPS') # Change column names to be mnemonic 
for (i in 1:nrow(IndData)){
  IndData$Sampling_Site[i] <- steelhead.metadata %>% filter(Sample_ID == IndData$Ind1[i]) %>% select(Location)
}
temp_IndData <- as.matrix(IndData)
write.csv(temp_IndData, file = paste0("steelhead_dps.csv"), row.names = FALSE)
rm(temp_IndData)  
```

